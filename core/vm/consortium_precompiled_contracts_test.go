package vm

import (
	"bytes"
	"crypto/ecdsa"
	"fmt"
	"math/big"
	"math/rand"
	"strings"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/core/rawdb"
	"github.com/ethereum/go-ethereum/core/state"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/crypto/bls/blst"
	blsCommon "github.com/ethereum/go-ethereum/crypto/bls/common"
	"github.com/ethereum/go-ethereum/params"
	"github.com/stretchr/testify/assert"
)

/*
*
testSortCodes is generated based on the following code
```
// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.0 <0.9.0;

	contract Validators {
	    address[] _validators = [
	    0x0000000000000000000000000000000000000010,
	    0x0000000000000000000000000000000000000011,
	    0x0000000000000000000000000000000000000012,
	    0x0000000000000000000000000000000000000013,
	    0x0000000000000000000000000000000000000014,
	    0x0000000000000000000000000000000000000015,
	    0x0000000000000000000000000000000000000016,
	    0x0000000000000000000000000000000000000017,
	    0x0000000000000000000000000000000000000018,
	    0x0000000000000000000000000000000000000019,
	    0x0000000000000000000000000000000000000020,
	    0x0000000000000000000000000000000000000021,
	    0x0000000000000000000000000000000000000022,
	    0x0000000000000000000000000000000000000023,
	    0x0000000000000000000000000000000000000024,
	    0x0000000000000000000000000000000000000025,
	    0x0000000000000000000000000000000000000026,
	    0x0000000000000000000000000000000000000027,
	    0x0000000000000000000000000000000000000028,
	    0x0000000000000000000000000000000000000029,
	    0x0000000000000000000000000000000000000030
	    ];
	    uint256[] _totalBalances = [1,4,6,2,8,9,10,3,16,20,100,12,22,30,50,60,5,18,16,22,21];
		constructor() {}
	    function getValidatorCandidates() public view returns (address[] memory _validatorList) {
	        _validatorList = _validators;
	    }
	    function totalBalances(address[] calldata _poolList) public view returns (uint256[] memory _balances) {
	        _balances = _totalBalances;
	    }
	}

```
*/
const testSortCode = `6080604052604051806102a00160405280601073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001601973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001602973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001603073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815250600090601561044d92919061054d565b50604051806102a00160405280600160ff168152602001600460ff168152602001600660ff168152602001600260ff168152602001600860ff168152602001600960ff168152602001600a60ff168152602001600360ff168152602001601060ff168152602001601460ff168152602001606460ff168152602001600c60ff168152602001601660ff168152602001601e60ff168152602001603260ff168152602001603c60ff168152602001600560ff168152602001601260ff168152602001601060ff168152602001601660ff168152602001601560ff16815250600190601561053a9291906105d7565b5034801561054757600080fd5b50610646565b8280548282559060005260206000209081019282156105c6579160200282015b828111156105c55782518260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055509160200191906001019061056d565b5b5090506105d39190610629565b5090565b828054828255906000526020600020908101928215610618579160200282015b82811115610617578251829060ff169055916020019190600101906105f7565b5b5090506106259190610629565b5090565b5b8082111561064257600081600090555060010161062a565b5090565b610460806106556000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80634a5d76cd1461003b578063ba77b06c1461006b575b600080fd5b610055600480360381019061005091906101e1565b610089565b60405161006291906102f6565b60405180910390f35b6100736100e4565b6040516100809190610408565b60405180910390f35b606060018054806020026020016040519081016040528092919081815260200182805480156100d757602002820191906000526020600020905b8154815260200190600101908083116100c3575b5050505050905092915050565b6060600080548060200260200160405190810160405280929190818152602001828054801561016857602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161011e575b5050505050905090565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f8401126101a1576101a061017c565b5b8235905067ffffffffffffffff8111156101be576101bd610181565b5b6020830191508360208202830111156101da576101d9610186565b5b9250929050565b600080602083850312156101f8576101f7610172565b5b600083013567ffffffffffffffff81111561021657610215610177565b5b6102228582860161018b565b92509250509250929050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000819050919050565b61026d8161025a565b82525050565b600061027f8383610264565b60208301905092915050565b6000602082019050919050565b60006102a38261022e565b6102ad8185610239565b93506102b88361024a565b8060005b838110156102e95781516102d08882610273565b97506102db8361028b565b9250506001810190506102bc565b5085935050505092915050565b600060208201905081810360008301526103108184610298565b905092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061036f82610344565b9050919050565b61037f81610364565b82525050565b60006103918383610376565b60208301905092915050565b6000602082019050919050565b60006103b582610318565b6103bf8185610323565b93506103ca83610334565b8060005b838110156103fb5781516103e28882610385565b97506103ed8361039d565b9250506001810190506103ce565b5085935050505092915050565b6000602082019050818103600083015261042281846103aa565b90509291505056fea26469706673582212204aab6725297603e4a73daf57fffdd55330e60293dfde78dcbbddb9178144583064736f6c63430008110033`

/*
*
wrapupCode is used to call sortValidators precompiled contract with the following code
```
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.0 <0.9.0;

	contract Wrapup {
	    constructor() {}

	    address[] _validators = [
	        0x0000000000000000000000000000000000000064,
	        0x0000000000000000000000000000000000000065,
	        0x0000000000000000000000000000000000000066,
	        0x0000000000000000000000000000000000000067,
	        0x0000000000000000000000000000000000000068,
	        0x0000000000000000000000000000000000000069,
	        0x000000000000000000000000000000000000006a,
	        0x000000000000000000000000000000000000006b,
	        0x000000000000000000000000000000000000006C,
	        0x000000000000000000000000000000000000006D,
	        0x000000000000000000000000000000000000006E,
	        0x000000000000000000000000000000000000006F,
	        0x0000000000000000000000000000000000000070,
	        0x0000000000000000000000000000000000000071,
	        0x0000000000000000000000000000000000000072,
	        0x0000000000000000000000000000000000000073,
	        0x0000000000000000000000000000000000000074,
	        0x0000000000000000000000000000000000000075,
	        0x0000000000000000000000000000000000000076,
	        0x0000000000000000000000000000000000000077,
	        0x0000000000000000000000000000000000000078
	    ];
	    uint256[] _weights = [
	        uint256(1000),
	        uint256(2000),
	        uint256(3000),
	        uint256(4000),
	        uint256(5000),
	        uint256(6000),
	        uint256(7000),
	        uint256(8000),
	        uint256(9000),
	        uint256(10000),
	        uint256(11000),
	        uint256(12000),
	        uint256(13000),
	        uint256(14000),
	        uint256(15000),
	        uint256(16000),
	        uint256(17000),
	        uint256(18000),
	        uint256(19000),
	        uint256(20000),
	        uint256(21000)
	    ];

	    function sortValidators() public view returns (address[3] memory _result) {
	        bytes memory payload = abi.encodeWithSignature(
	            "sortValidators(address[],uint256[])",
	            _validators,
	            _weights
	        );

	        uint256 payloadLength = payload.length;
	        uint256 validatorsLength = _validators.length;
	        uint256 validatorsLengthHex = validatorsLength * 0x20;
	        uint256 validatorsLengthHex64 = validatorsLength * 0x20 + 64;
	        address _smc = address(0x66);

	        assembly {
	            let payloadStart := add(payload, 32)
	            if iszero(
	                staticcall(
	                    gas(),
	                    _smc,
	                    payloadStart,
	                    payloadLength,
	                    _result,
	                    validatorsLengthHex64
	                )
	            ) {
	                revert(0, 0)
	            }
	            returndatacopy(_result, 64, validatorsLengthHex)
	            return(_result, validatorsLengthHex)
	        }
	    }
	}

```
*/
const (
	wrapupCode = "6080604052604051806102a00160405280606473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606f73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815250600090601561044d929190610523565b50604051806102a001604052806103e881526020016107d08152602001610bb88152602001610fa0815260200161138881526020016117708152602001611b588152602001611f40815260200161232881526020016127108152602001612af88152602001612ee081526020016132c881526020016136b08152602001613a988152602001613e80815260200161426881526020016146508152602001614a388152602001614e20815260200161520881525060019060156105109291906105ad565b5034801561051d57600080fd5b50610617565b82805482825590600052602060002090810192821561059c579160200282015b8281111561059b5782518260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555091602001919060010190610543565b5b5090506105a991906105fa565b5090565b8280548282559060005260206000209081019282156105e9579160200282015b828111156105e85782518255916020019190600101906105cd565b5b5090506105f691906105fa565b5090565b5b808211156106135760008160009055506001016105fb565b5090565b61057f806106266000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806327167aec14610030575b600080fd5b61003861004e565b604051610045919061024a565b60405180910390f35b61005661014b565b600080600160405160240161006c92919061046d565b6040516020818303038152906040527f788341af000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050509050600081519050600080805490509050600060208261010991906104d3565b90506000604060208461011c91906104d3565b6101269190610515565b90506000606690506020860182888783855afa61014257600080fd5b836040893e8388f35b6040518060600160405280600390602082028036833780820191505090505090565b600060039050919050565b600081905092915050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006101b88261018d565b9050919050565b6101c8816101ad565b82525050565b60006101da83836101bf565b60208301905092915050565b6000602082019050919050565b6101fc8161016d565b6102068184610178565b925061021182610183565b8060005b8381101561024257815161022987826101ce565b9650610234836101e6565b925050600181019050610215565b505050505050565b600060608201905061025f60008301846101f3565b92915050565b600081549050919050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b60008160001c9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006102d66102d183610296565b6102a3565b9050919050565b60006102e982546102c3565b9050919050565b6000600182019050919050565b600061030882610265565b6103128185610270565b935061031d83610281565b8060005b8381101561035557610332826102dd565b61033c88826101ce565b9750610347836102f0565b925050600181019050610321565b5085935050505092915050565b600081549050919050565b600082825260208201905092915050565b60008190508160005260206000209050919050565b6000819050919050565b6103a681610393565b82525050565b60006103b8838361039d565b60208301905092915050565b6000819050919050565b60006103e16103dc83610296565b6103c4565b9050919050565b60006103f482546103ce565b9050919050565b6000600182019050919050565b600061041382610362565b61041d818561036d565b93506104288361037e565b8060005b838110156104605761043d826103e8565b61044788826103ac565b9750610452836103fb565b92505060018101905061042c565b5085935050505092915050565b6000604082019050818103600083015261048781856102fd565b9050818103602083015261049b8184610408565b90509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006104de82610393565b91506104e983610393565b92508282026104f781610393565b9150828204841483151761050e5761050d6104a4565b5b5092915050565b600061052082610393565b915061052b83610393565b9250828201905080821115610543576105426104a4565b5b9291505056fea26469706673582212209c0a26634f0573266e0920a580ad0aa466f5f1be2bd12450465d114e981b1e7464736f6c63430008120033"
	wrapupAbi  = `[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"sortValidators","outputs":[{"internalType":"address[21]","name":"_validators","type":"address[21]"}],"stateMutability":"view","type":"function"}]`
)

/*
*
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.0 <0.9.0;

	contract SyncNewValidatorSet {
	    constructor() {}

	    address[] _candidates = [
	        0x0000000000000000000000000000000000000064,
	        0x0000000000000000000000000000000000000065,
	        0x0000000000000000000000000000000000000066,
	        0x0000000000000000000000000000000000000067,
	        0x0000000000000000000000000000000000000068,
	        0x0000000000000000000000000000000000000069,
	        0x000000000000000000000000000000000000006a,
	        0x000000000000000000000000000000000000006b,
	        0x000000000000000000000000000000000000006C,
	        0x000000000000000000000000000000000000006D,
	        0x000000000000000000000000000000000000006E,
	        0x000000000000000000000000000000000000006F,
	        0x0000000000000000000000000000000000000070,
	        0x0000000000000000000000000000000000000071,
	        0x0000000000000000000000000000000000000072,
	        0x0000000000000000000000000000000000000073,
	        0x0000000000000000000000000000000000000074,
	        0x0000000000000000000000000000000000000075,
	        0x0000000000000000000000000000000000000076,
	        0x0000000000000000000000000000000000000077,
	        0x0000000000000000000000000000000000000078
	    ];
	    uint256[] _weights = [
	        uint256(1000000),
	        uint256(2000000),
	        uint256(3000000),
	        uint256(4000000),
	        uint256(5000000),
	        uint256(6000000),
	        uint256(7000000),
	        uint256(8000000),
	        uint256(9000000),
	        uint256(10000000),
	        uint256(11000000),
	        uint256(12000000),
	        uint256(13000000),
	        uint256(14000000),
	        uint256(15000000),
	        uint256(16000000),
	        uint256(17000000),
	        uint256(18000000),
	        uint256(19000000),
	        uint256(20000000),
	        uint256(21000000)
	    ];
		uint256[] _isTrustedOrganizations = [
			uint256(0),
			uint256(0),
			uint256(0),
			uint256(0),
			uint256(0),
			uint256(0),
			uint256(0),
			uint256(0),
			uint256(0),
			uint256(0),
			uint256(1),
			uint256(1),
			uint256(1),
			uint256(1),
			uint256(1),
			uint256(1),
			uint256(1),
			uint256(1),
			uint256(1),
			uint256(1),
			uint256(1)
		];
	    uint256 _maxValidatorNumber = 21;
	    uint256 _maxPrioritizedValidatorNumber = 11;

	    function pickValidatorSet() public view returns (address[] memory _result) {
	        bytes memory _payload = abi.encodeWithSignature(
	            "pickValidatorSet(address[],uint256[],uint256[],uint256,uint256)",
	            _candidates,
	            _weights,
	            _isTrustedOrganizations,
	            _maxValidatorNumber,
	            _maxPrioritizedValidatorNumber
	        );
	        bool _success = true;

	        uint256 _payloadLength = _payload.length;
	        uint256 _resultLength = 0x20 * _candidates.length + 0x40;
	        address _smc = address(0x68);

	        assembly {
	            let _payloadStart := add(_payload, 0x20)

	            if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {
	                _success := 0
	            }

	            if iszero(returndatasize()) {
	                _success := 0
	            }

	            _result := add(_result, 0x20)
	        }

	        require(_success, "PrecompileUsageSortValidators: call to precompile fails");
	    }
	}
*/
const (
	syncNewValidatorSetCode = `6080604052604051806102a00160405280606473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606d73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001606f73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001607873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815250600090601561044d9291906105f5565b50604051806102a00160405280620f42408152602001621e84808152602001622dc6c08152602001623d09008152602001624c4b408152602001625b8d808152602001626acfc08152602001627a1200815260200162895440815260200162989680815260200162a7d8c0815260200162b71b00815260200162c65d40815260200162d59f80815260200162e4e1c0815260200162f42400815260200163010366408152602001630112a8808152602001630121eac081526020016301312d0081526020016301406f40815250600190601561052a92919061067f565b50604051806102a001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160018152602001600181526020016001815260200160018152602001600181526020016001815260200160018152602001600181526020016001815260200160018152602001600181525060029060156105d892919061067f565b506015600355600b6004553480156105ef57600080fd5b506106e9565b82805482825590600052602060002090810192821561066e579160200282015b8281111561066d5782518260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555091602001919060010190610615565b5b50905061067b91906106cc565b5090565b8280548282559060005260206000209081019282156106bb579160200282015b828111156106ba57825182559160200191906001019061069f565b5b5090506106c891906106cc565b5090565b5b808211156106e55760008160009055506001016106cd565b5090565b6106de806106f86000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063c80c0b6c14610030575b600080fd5b61003861004f565b604051610046929190610340565b60405180910390f35b6060600080600060016002600354600454604051602401610074959493929190610370565b6040516020818303038152906040527f77941512000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505090506000600190506000825190506000604060008054905060206101159190610503565b61011f91906104ad565b90506000606890506020850182888583855afa61013b57600094505b3d61014557600094505b879650602088019750508361018f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610186906103d8565b60405180910390fd5b50505050509091565b60006101a483836101c8565b60208301905092915050565b60006101bc8383610322565b60208301905092915050565b6101d181610587565b82525050565b60006101e282610432565b6101ec818561047a565b93506101f7836103f8565b8060005b8381101561022857815161020f8882610198565b975061021a83610453565b9250506001810190506101fb565b5085935050505092915050565b60006102408261043d565b61024a818561047a565b935061025583610408565b8060005b8381101561028d5761026a82610626565b6102748882610198565b975061027f83610460565b925050600181019050610259565b5085935050505092915050565b60006102a582610448565b6102af818561048b565b93506102ba8361041d565b8060005b838110156102f2576102cf82610639565b6102d988826101b0565b97506102e48361046d565b9250506001810190506102be565b5085935050505092915050565b600061030c60378361049c565b915061031782610659565b604082019050919050565b61032b816105b9565b82525050565b61033a816105b9565b82525050565b6000604082019050818103600083015261035a81856101d7565b90506103696020830184610331565b9392505050565b600060a082019050818103600083015261038a8188610235565b9050818103602083015261039e818761029a565b905081810360408301526103b2818661029a565b90506103c16060830185610331565b6103ce6080830184610331565b9695505050505050565b600060208201905081810360008301526103f1816102ff565b9050919050565b6000819050602082019050919050565b60008190508160005260206000209050919050565b60008190508160005260206000209050919050565b600081519050919050565b600081549050919050565b600081549050919050565b6000602082019050919050565b6000600182019050919050565b6000600182019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600082825260208201905092915050565b60006104b8826105b9565b91506104c3836105b9565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156104f8576104f76105f7565b5b828201905092915050565b600061050e826105b9565b9150610519836105b9565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615610552576105516105f7565b5b828202905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061059282610599565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006105d66105d18361064c565b61055d565b9050919050565b60006105f06105eb8361064c565b61057d565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061063282546105c3565b9050919050565b600061064582546105dd565b9050919050565b60008160001c9050919050565b7f507265636f6d70696c655573616765536f727456616c696461746f72733a206360008201527f616c6c20746f20707265636f6d70696c65206661696c7300000000000000000060208201525056fea264697066735822122085ebbb8c16b63d8e71a6315b0c7b1ad88e35ddb36d250664b845bfe23027c0c064736f6c63430008070033`
	syncNewValidatorSetAbi  = `[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"pickValidatorSet","outputs":[{"internalType":"address[]","name":"_result","type":"address[]"},{"internalType":"uint256","name":"_newValidatorCount","type":"uint256"}],"stateMutability":"view","type":"function"}]`
)

var (
	caller             = common.BytesToAddress([]byte("sender"))
	expectedValidators = []common.Address{
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),
		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),
	}
)

/*
*
verifyHeadersTestCode represents the following smart contract code
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.0 <0.9.0;

contract VerifyHeaderTestContract {

	    constructor() {}

	    function verify(address consensusAddr, bytes memory header1, bytes memory header2) public view returns (bool) {
	        bytes memory payload = abi.encodeWithSignature("validatingDoubleSignProof(address,bytes,bytes)", consensusAddr, header1, header2);
	        uint payloadLength = payload.length;
	        address _smc = address(0x67);
	        uint[1] memory _output;
	        assembly {
	            let payloadStart := add(payload, 32)
	            if iszero(staticcall(gas(), _smc, payloadStart, payloadLength, _output, 0x20)) {
	                revert(0, 0)
	            }
	        }
	        return (_output[0] != 0);
	    }

		function getDoubleSignSlashingConfigs() public view returns (uint256,uint256,uint256) {
			return (0, 0, 28800);
		}
	}
*/
const (
	verifyHeadersTestCode = "608060405234801561001057600080fd5b506105af806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80635ade66331461003b578063df4b6ee01461006b575b600080fd5b61005560048036038101906100509190610366565b61008b565b604051610062919061040c565b60405180910390f35b610073610176565b60405161008293929190610440565b60405180910390f35b6000808484846040516024016100a393929190610505565b6040516020818303038152906040527f7fc35677000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050905060008151905060006067905061013661018c565b602084016020828583865afa61014b57600080fd5b506000816000600181106101625761016161054a565b5b602002015114159450505050509392505050565b6000806000806000617080925092509250909192565b6040518060200160405280600190602082028036833780820191505090505090565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006101ed826101c2565b9050919050565b6101fd816101e2565b811461020857600080fd5b50565b60008135905061021a816101f4565b92915050565b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6102738261022a565b810181811067ffffffffffffffff821117156102925761029161023b565b5b80604052505050565b60006102a56101ae565b90506102b1828261026a565b919050565b600067ffffffffffffffff8211156102d1576102d061023b565b5b6102da8261022a565b9050602081019050919050565b82818337600083830152505050565b6000610309610304846102b6565b61029b565b90508281526020810184848401111561032557610324610225565b5b6103308482856102e7565b509392505050565b600082601f83011261034d5761034c610220565b5b813561035d8482602086016102f6565b91505092915050565b60008060006060848603121561037f5761037e6101b8565b5b600061038d8682870161020b565b935050602084013567ffffffffffffffff8111156103ae576103ad6101bd565b5b6103ba86828701610338565b925050604084013567ffffffffffffffff8111156103db576103da6101bd565b5b6103e786828701610338565b9150509250925092565b60008115159050919050565b610406816103f1565b82525050565b600060208201905061042160008301846103fd565b92915050565b6000819050919050565b61043a81610427565b82525050565b60006060820190506104556000830186610431565b6104626020830185610431565b61046f6040830184610431565b949350505050565b610480816101e2565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b838110156104c05780820151818401526020810190506104a5565b60008484015250505050565b60006104d782610486565b6104e18185610491565b93506104f18185602086016104a2565b6104fa8161022a565b840191505092915050565b600060608201905061051a6000830186610477565b818103602083015261052c81856104cc565b9050818103604083015261054081846104cc565b9050949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220dc019b9821e90fec0a5c0be6a93228b7e4c926289e45ad5cce1f893e0dc3267f64736f6c63430008120033"
	verifyHeadersTestAbi  = `[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"getDoubleSignSlashingConfigs","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"consensusAddr","type":"address"},{"internalType":"bytes","name":"header1","type":"bytes"},{"internalType":"bytes","name":"header2","type":"bytes"}],"name":"verify","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]`
)

type TestScenario struct {
	Address   common.Address
	Weight    *big.Int
	IsTrusted *big.Int
}

func getTestScenarios() []TestScenario {
	return []TestScenario{
		{
			Address:   common.BytesToAddress([]byte{100}),
			Weight:    big.NewInt(1_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{101}),
			Weight:    big.NewInt(2_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{102}),
			Weight:    big.NewInt(3_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{103}),
			Weight:    big.NewInt(4_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{104}),
			Weight:    big.NewInt(5_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{105}),
			Weight:    big.NewInt(6_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{106}),
			Weight:    big.NewInt(7_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{107}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{108}),
			Weight:    big.NewInt(9_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{109}),
			Weight:    big.NewInt(10_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{110}),
			Weight:    big.NewInt(11_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{111}),
			Weight:    big.NewInt(12_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{112}),
			Weight:    big.NewInt(13_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{113}),
			Weight:    big.NewInt(14_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{114}),
			Weight:    big.NewInt(15_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{115}),
			Weight:    big.NewInt(16_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{116}),
			Weight:    big.NewInt(17_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{117}),
			Weight:    big.NewInt(18_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{118}),
			Weight:    big.NewInt(19_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{119}),
			Weight:    big.NewInt(20_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{120}),
			Weight:    big.NewInt(21_000_000),
			IsTrusted: big0,
		},
	}
}

func getAddresses(scenarios []TestScenario) []common.Address {
	var result []common.Address
	for _, s := range scenarios {
		result = append(result, s.Address)
	}

	return result
}

func getWeights(scenarios []TestScenario) []*big.Int {
	var result []*big.Int
	for _, s := range scenarios {
		result = append(result, s.Weight)
	}

	return result
}

func getIsTrusted(scenarios []TestScenario) []*big.Int {
	var result []*big.Int
	for _, s := range scenarios {
		result = append(result, s.IsTrusted)
	}

	return result
}

func setIsTrustedAt(scenarios []TestScenario, indexes ...int64) {
	for _, i := range indexes {
		scenarios[i].IsTrusted = big1
	}
}

var (
	addressesTest = []common.Address{
		common.BytesToAddress([]byte{100}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{111}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{120}),
	}
	weightsTest = []*big.Int{
		big.NewInt(1_000_000),
		big.NewInt(2_000_000),
		big.NewInt(3_000_000),
		big.NewInt(4_000_000),
		big.NewInt(5_000_000),
		big.NewInt(6_000_000),
		big.NewInt(7_000_000),
		big.NewInt(8_000_000),
		big.NewInt(9_000_000),
		big.NewInt(10_000_000),
		big.NewInt(11_000_000),
		big.NewInt(12_000_000),
		big.NewInt(13_000_000),
		big.NewInt(14_000_000),
		big.NewInt(15_000_000),
		big.NewInt(16_000_000),
		big.NewInt(17_000_000),
		big.NewInt(18_000_000),
		big.NewInt(19_000_000),
		big.NewInt(20_000_000),
		big.NewInt(22_000_000),
	}
)

func TestSort(t *testing.T) {
	fmt.Println(common.BytesToAddress([]byte{101}))
	addrs := []common.Address{
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{106}),
	}

	totalBalances := []*big.Int{
		big.NewInt(10),
		big.NewInt(2),
		big.NewInt(11),
		big.NewInt(15),
		big.NewInt(1),
	}

	expectedAddrs := []common.Address{
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{106}),
	}

	expectedBalances := []*big.Int{
		big.NewInt(15),
		big.NewInt(11),
		big.NewInt(10),
		big.NewInt(2),
		big.NewInt(1),
	}

	sortValidators(addrs, totalBalances)
	for i, val := range addrs {
		if expectedBalances[i].Cmp(totalBalances[i]) != 0 {
			t.Fatal(fmt.Sprintf("mismatched balance at %d, expected:%s got:%s", i, expectedBalances[i].String(), totalBalances[i].String()))
		}
		if expectedAddrs[i].Hex() != val.Hex() {
			t.Fatal(fmt.Sprintf("mismatched addr at %d, expected:%s got:%s", i, expectedValidators[i].Hex(), val.Hex()))
		}
	}
}

// TestConsortiumValidatorSorting_Run sorts 21 validators successfully
func TestConsortiumValidatorSorting_Run(t *testing.T) {
	var (
		statedb, _ = state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)
	)

	smcAbi := *unmarshalledABIs[SortValidator]

	input, err := smcAbi.Pack(sortValidatorsMethod, addressesTest, weightsTest)

	if err != nil {
		t.Fatal(err)
	}

	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	c := &consortiumValidatorSorting{caller: AccountRef(caller), evm: evm}
	output, err := c.Run(input)
	if err != nil {
		t.Fatal(err)
	}
	//println(common.Bytes2Hex(output))

	res, err := smcAbi.Methods[sortValidatorsMethod].Outputs.Unpack(output)
	if err != nil {
		t.Fatal(err)
	}
	sortedValidators := *abi.ConvertType(res[0], new([21]common.Address)).(*[21]common.Address)
	if len(expectedValidators) != len(sortedValidators) {
		t.Fatal(fmt.Sprintf("expected len %d, got %v", 21, len(sortedValidators)))
	}
	for i, addr := range sortedValidators {
		//println(addr.Hex())
		if expectedValidators[i].Hex() != addr.Hex() {
			t.Fatal(fmt.Sprintf("mismatched addr at %d, expected:%s got:%s", i, expectedValidators[i].Hex(), addr.Hex()))
		}
	}
}

// TestConsortiumValidatorSorting_Run2 simulates a call from a user who trigger system contract to call `sort` precompiled contract
func TestConsortiumValidatorSorting_Run2(t *testing.T) {
	var (
		statedb, _ = state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)
	)
	smcAbi, err := abi.JSON(strings.NewReader(wrapupAbi))
	if err != nil {
		t.Fatal(err)
	}
	input, err := smcAbi.Pack(sortValidatorsMethod)
	if err != nil {
		t.Fatal(err)
	}

	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	_, contract, _, err := evm.Create(AccountRef(caller), common.FromHex(wrapupCode), math.MaxUint64/2, big0)
	if err != nil {
		t.Fatal(err)
	}

	// set this contract into consortiumV2Contracts to make it become a system contract
	evm.chainConfig.ConsortiumV2Contracts.SlashIndicator = contract

	ret, _, err := evm.StaticCall(AccountRef(caller), contract, input, 1000000)
	if err != nil {
		t.Fatal(err)
	}

	res, err := smcAbi.Methods[sortValidatorsMethod].Outputs.Unpack(ret)
	if err != nil {
		t.Fatal(err)
	}

	sortedValidators := *abi.ConvertType(res[0], new([21]common.Address)).(*[21]common.Address)
	if len(expectedValidators) != len(sortedValidators) {
		t.Fatal(fmt.Sprintf("expected len 21, got %v", len(sortedValidators)))
	}
	for i, addr := range sortedValidators {
		if expectedValidators[i].Hex() != addr.Hex() {
			t.Fatal(fmt.Sprintf("mismatched addr at %d, expected:%s got:%s", i, expectedValidators[i].Hex(), addr.Hex()))
		}
	}
}

func BenchmarkConsortiumValidatorSorting(b *testing.B) {
	smcAbi, err := abi.JSON(strings.NewReader(rawConsortiumSortValidatorAbi))
	if err != nil {
		b.Fatal(err)
	}

	var (
		addresses []common.Address
		weights   []*big.Int
	)
	for i := 0; i < 22; i++ {
		addresses = append(addresses, common.BytesToAddress([]byte{uint8(i)}))
		weights = append(weights, big.NewInt(rand.Int63()))
	}

	input, err := smcAbi.Pack(sortValidatorsMethod, addresses, weights)
	if err != nil {
		b.Fatal(err)
	}

	c := &consortiumValidatorSorting{}
	output, err := c.Run(input)
	if err != nil {
		b.Fatal(err)
	}

	test := precompiledTest{
		Input:    common.Bytes2Hex(input),
		Expected: common.Bytes2Hex(output),
		Name:     "validator-sort",
	}

	benchmarkPrecompiled("66", test, b)

	addresses = nil
	weights = nil
	for i := 0; i < 100; i++ {
		addresses = append(addresses, common.BytesToAddress([]byte{uint8(i)}))
		weights = append(weights, big.NewInt(rand.Int63()))
	}

	input, err = smcAbi.Pack(sortValidatorsMethod, addresses, weights)
	if err != nil {
		b.Fatal(err)
	}

	output, err = c.Run(input)
	if err != nil {
		b.Fatal(err)
	}

	test = precompiledTest{
		Input:    common.Bytes2Hex(input),
		Expected: common.Bytes2Hex(output),
		Name:     "validator-sort",
	}

	benchmarkPrecompiled("66", test, b)
}

// TestConsortiumVerifyHeaders_verify tests verify function
func TestConsortiumVerifyHeaders_verify(t *testing.T) {
	header1, header2, err := prepareHeader(big1)
	if err != nil {
		t.Fatal(err)
	}
	c := &consortiumVerifyHeaders{
		evm: &EVM{
			chainConfig: &params.ChainConfig{ChainID: big1, ConsortiumV2Block: big.NewInt(500)},
			Context:     BlockContext{BlockNumber: header1.Number},
		},
		test: true,
	}
	if !c.verify(header1.Coinbase, types.FromHeader(header1, big1, false), types.FromHeader(header2, big1, false)) {
		t.Fatal("expected true, got false")
	}

	// Test the same headers passed into verify
	if c.verify(header1.Coinbase, types.FromHeader(header1, big1, false), types.FromHeader(header1, big1, false)) {
		t.Fatal("expected false, got true")
	}

	// Test consensus address is different from header.Coinbase
	if c.verify(common.Address{}, types.FromHeader(header1, big1, false), types.FromHeader(header2, big1, false)) {
		t.Fatal("expected false, got true")
	}

	// Test current block is lower than double signed block
	c.evm.Context.BlockNumber = new(big.Int).Sub(header1.Number, common.Big1)
	if !c.verify(header1.Coinbase, types.FromHeader(header1, big1, false), types.FromHeader(header2, big1, false)) {
		t.Fatal("expected true, got false")
	}

	// Test current block is higher than signed block but lower than signed block + 28800
	c.evm.Context.BlockNumber = new(big.Int).Add(header1.Number, big.NewInt(500))
	if !c.verify(header1.Coinbase, types.FromHeader(header1, big1, false), types.FromHeader(header2, big1, false)) {
		t.Fatal("expected true, got false")
	}

	// Test current block is higher than signed block + 28800
	c.evm.Context.BlockNumber = new(big.Int).Add(header1.Number, big.NewInt(28801))
	if c.verify(header1.Coinbase, types.FromHeader(header1, big1, false), types.FromHeader(header2, big1, false)) {
		t.Fatal("expected false, got true")
	}

	// Test too small header's extra data
	header1.Extra = nil
	if c.verify(header1.Coinbase, types.FromHeader(header1, big1, false), types.FromHeader(header2, big1, false)) {
		t.Fatal("expected false, got true")
	}
}

// TestConsortiumVerifyHeaders_Run init 2 headers and call `Run` function directly
func TestConsortiumVerifyHeaders_Run(t *testing.T) {
	statedb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)
	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	type headerGenerators func() (*types.Header, *types.Header, bool)
	key, err := crypto.GenerateKey()
	if err != nil {
		t.Fatal(err)
	}
	chainId := big1

	tests := []struct {
		name    string
		args    headerGenerators
		want    byte
		wantErr bool
	}{
		{
			"Test verify legacy headers should valid",
			func() (*types.Header, *types.Header, bool) {
				header1, header2, err := prepareHeader(evm.chainConfig.ChainID)
				if err != nil {
					t.Fatal(err)
				}
				return header1, header2, false
			},
			1,
			false,
		},
		{
			"Test verify valid headers after Venoki",
			func() (*types.Header, *types.Header, bool) {
				header1 := mockVenokiHeader(key)
				header2 := mockVenokiHeader(key)
				header2.Root = common.HexToHash("0x1234")

				extraData := bytes.Repeat([]byte{0x00}, extraVanity)
				// append to extraData with validators set
				extraData = append(extraData, common.BytesToAddress([]byte("validator1")).Bytes()...)
				extraData = append(extraData, common.BytesToAddress([]byte("validator2")).Bytes()...)
				// add extra seal space
				extraData = append(extraData, make([]byte, crypto.SignatureLength)...)

				header1.Extra = make([]byte, len(extraData))
				copy(header1.Extra[:], extraData)

				header2.Extra = make([]byte, len(extraData))
				copy(header2.Extra[:], extraData)

				signHeader(key, header1, chainId, true)
				signHeader(key, header2, chainId, true)
				return header1, header2, true
			},
			1,
			false,
		},
		{
			"Test verify headers with invalid baseFee, blobGasUsed, excessBlobGas, extraData",
			func() (*types.Header, *types.Header, bool) {
				header1 := mockVenokiHeader(key)
				header2 := mockVenokiHeader(key)
				gas := uint64(100_000)
				excessGas := uint64(10_000)
				header1.BaseFee = big.NewInt(20_000)
				header1.BlobGasUsed = &gas
				header1.ExcessBlobGas = &excessGas
				header2.BaseFee = big.NewInt(10_000)
				header2.BlobGasUsed = &gas
				header2.ExcessBlobGas = &excessGas
				header2.Coinbase = common.Address{} // invalid coinbase

				extraData := bytes.Repeat([]byte{0x00}, extraVanity)
				// append to extraData with validators set
				extraData = append(extraData, common.BytesToAddress([]byte("validator1")).Bytes()...)
				extraData = append(extraData, common.BytesToAddress([]byte("validator2")).Bytes()...)
				// add extra seal space
				extraData = append(extraData, make([]byte, crypto.SignatureLength)...)

				header1.Extra = make([]byte, len(extraData))
				copy(header1.Extra[:], extraData)

				header2.Extra = make([]byte, len(extraData))
				copy(header2.Extra[:], extraData)

				signHeader(key, header1, chainId, true)
				signHeader(key, header2, chainId, true)
				return header1, header2, true
			},
			0,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			smcAbi := *unmarshalledABIs[VerifyHeaders]
			header1, header2, isVenoki := tt.args()
			abi := rawConsortiumVerifyHeadersAbi
			if isVenoki {
				abi = rawConsortiumVerifyHeadersV2Abi
			}
			evm.chainRules.IsVenoki = isVenoki

			blockHeader1 := types.FromHeader(header1, chainId, isVenoki)
			blockHeader2 := types.FromHeader(header2, chainId, isVenoki)

			encodedHeader1, err := blockHeader1.Bytes(abi, getHeader)
			if err != nil {
				t.Fatal(err)
			}
			encodedHeader2, err := blockHeader2.Bytes(abi, getHeader)
			if err != nil {
				t.Fatal(err)
			}
			input, err := smcAbi.Pack(verifyHeaders, header1.Coinbase, encodedHeader1, encodedHeader2)
			if err != nil {
				t.Fatal(err)
			}
			c := &consortiumVerifyHeaders{evm: evm, caller: AccountRef(caller), test: true}
			result, err := c.Run(input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Run() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if len(result) != 32 {
				t.Fatal(fmt.Sprintf("expected len 32 got %d", len(result)))
			}
			if result[len(result)-1] != tt.want {
				t.Fatal(fmt.Sprintf("expected %v got %d", tt.want, result[len(result)-1]))
			}
		})
	}
}

func TestConsortiumVerifyHeaders_malleability(t *testing.T) {
	n, _ := new(big.Int).SetString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16)

	header1, _, err := prepareHeader(big1)
	if err != nil {
		t.Fatal(err)
	}

	var sig1 []byte = make([]byte, crypto.SignatureLength)
	nbytes := copy(sig1, header1.Extra[len(header1.Extra)-crypto.SignatureLength:])
	if nbytes != crypto.SignatureLength {
		t.Fatal("copy signature from header1 failed")
	}
	var header2 *types.Header = types.CopyHeader(header1)

	var sig2 []byte = make([]byte, crypto.SignatureLength)
	copy(sig2, sig1)
	s1 := new(big.Int).SetBytes(sig1[32:64])
	var s2 *big.Int = new(big.Int)
	s2.Sub(n, s1)
	nbytes = copy(sig2[32:], s2.Bytes())
	if nbytes != 32 {
		t.Fatal("copy s2 to sig2 failed")
	}

	v1 := sig1[len(sig1)-1]
	var v2 byte
	if v1 == 0 {
		v2 = 1
	} else {
		v2 = 0
	}
	sig2[len(sig2)-1] = v2

	nbytes = copy(header2.Extra[len(header2.Extra)-crypto.SignatureLength:], sig2)
	if nbytes != crypto.SignatureLength {
		t.Fatal("copy sig2 to header2 failed")
	}

	c := &consortiumVerifyHeaders{evm: &EVM{chainConfig: &params.ChainConfig{ChainID: big1}}, test: true}
	if c.verify(header1.Coinbase, types.FromHeader(header1, big1, false), types.FromHeader(header2, big1, false)) {
		t.Fatal("expected false, got true")
	}
}

// TestConsortiumVerifyHeaders_Run2 deploys smart contract and call precompiled contracts via this contract
func TestConsortiumVerifyHeaders_Run2(t *testing.T) {
	var (
		statedb, _ = state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)
	)
	smcAbi, err := abi.JSON(strings.NewReader(verifyHeadersTestAbi))
	if err != nil {
		t.Fatal(err)
	}
	header1, header2, err := prepareHeader(big1)
	if err != nil {
		t.Fatal(err)
	}
	encodedHeader1, err := types.FromHeader(header1, big1, false).Bytes(rawConsortiumVerifyHeadersAbi, getHeader)
	if err != nil {
		t.Fatal(err)
	}
	encodedHeader2, err := types.FromHeader(header2, big1, false).Bytes(rawConsortiumVerifyHeadersAbi, getHeader)
	if err != nil {
		t.Fatal(err)
	}
	input, err := smcAbi.Pack("verify", header1.Coinbase, encodedHeader1, encodedHeader2)
	if err != nil {
		t.Fatal(err)
	}
	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	_, contract, _, err := evm.Create(AccountRef(caller), common.FromHex(verifyHeadersTestCode), math.MaxUint64/2, big0)
	if err != nil {
		t.Fatal(err)
	}

	// set this contract into consortiumV2Contracts to make it become a system contract
	evm.chainConfig.ConsortiumV2Contracts.SlashIndicator = contract

	ret, _, err := evm.StaticCall(AccountRef(caller), contract, input, 1000000)
	if err != nil {
		t.Fatal(err)
	}

	res, err := smcAbi.Methods["verify"].Outputs.Unpack(ret)
	if err != nil {
		t.Fatal(err)
	}
	result := *abi.ConvertType(res[0], new(bool)).(*bool)
	if !result {
		t.Fatal("expected true got false")
	}
}

func BenchmarkConsortiumVerifyHeaders(b *testing.B) {
	smcAbi, err := abi.JSON(strings.NewReader(rawConsortiumVerifyHeadersAbi))
	if err != nil {
		b.Fatal(err)
	}
	header1, header2, err := prepareHeader(big1)
	if err != nil {
		b.Fatal(err)
	}
	encodedHeader1, err := types.FromHeader(header1, big1, false).Bytes(rawConsortiumVerifyHeadersAbi, getHeader)
	if err != nil {
		b.Fatal(err)
	}
	encodedHeader2, err := types.FromHeader(header2, big1, false).Bytes(rawConsortiumVerifyHeadersAbi, getHeader)
	if err != nil {
		b.Fatal(err)
	}
	input, err := smcAbi.Pack(verifyHeaders, header1.Coinbase, encodedHeader1, encodedHeader2)
	if err != nil {
		b.Fatal(err)
	}

	output, err := smcAbi.Methods[verifyHeaders].Outputs.Pack(true)
	if err != nil {
		b.Fatal(err)
	}

	test := precompiledTest{
		Input:    common.Bytes2Hex(input),
		Expected: common.Bytes2Hex(output),
		Name:     "verify-headers",
	}

	benchmarkPrecompiled("67", test, b)
}

// TestArrangeValidatorCandidates arranges 21 candidates with 11 trusted nodes (ordering)
func TestArrangeValidatorCandidates(t *testing.T) {
	scenarios := getTestScenarios()
	setIsTrustedAt(scenarios, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
	isTrustedOrganizations := getIsTrusted(scenarios)
	candidates := getAddresses(scenarios)
	weights := getWeights(scenarios)

	newValidatorCount := uint64(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	candidateMap := createCandidateMap(candidates, isTrustedOrganizations)
	sortValidators(candidates, weights)
	updateIsTrustedOrganizations(candidates, isTrustedOrganizations, candidateMap)
	arrangeValidatorCandidates(candidates, newValidatorCount, isTrustedOrganizations, maxPrioritizedValidatorNumber)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),

		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),
	}
	for i, candidate := range candidates {
		if !bytes.Equal(expectedCandidates[i].Bytes(), candidate.Bytes()) {
			t.Fatal(fmt.Sprintf("mismatched candidate address at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), candidate.Hex()))
		}
	}
}

// TestArrangeValidatorCandidates_RandomTrustedOrganizations arranges 21 candidates with 11 trusted nodes (randomly)
func TestArrangeValidatorCandidates_RandomTrustedOrganizations(t *testing.T) {
	scenarios := getTestScenarios()
	setIsTrustedAt(scenarios, 2, 5, 8, 10, 11, 13, 14, 17, 18, 19, 20)
	isTrustedOrganizations := getIsTrusted(scenarios)
	candidates := getAddresses(scenarios)
	weights := getWeights(scenarios)

	newValidatorCount := uint64(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	candidateMap := createCandidateMap(candidates, isTrustedOrganizations)
	sortValidators(candidates, weights)

	updateIsTrustedOrganizations(candidates, isTrustedOrganizations, candidateMap)
	arrangeValidatorCandidates(candidates, newValidatorCount, isTrustedOrganizations, maxPrioritizedValidatorNumber)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{111}),
		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{102}),

		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),
	}

	for i, candidate := range candidates {
		if !bytes.Equal(expectedCandidates[i].Bytes(), candidate.Bytes()) {
			t.Fatal(fmt.Sprintf("mismatched candidate address at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), candidate.Hex()))
		}
	}
}

// TestArrangeValidatorCandidates_Max5Prioritized arranges 21 candidates with 5 trusted nodes (ordering)
func TestArrangeValidatorCandidates_Max5Prioritized(t *testing.T) {
	scenarios := getTestScenarios()
	setIsTrustedAt(scenarios, 16, 17, 18, 19, 20)
	isTrustedOrganizations := getIsTrusted(scenarios)
	candidates := getAddresses(scenarios)
	weights := getWeights(scenarios)

	newValidatorCount := uint64(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	candidateMap := createCandidateMap(candidates, isTrustedOrganizations)
	sortValidators(candidates, weights)
	updateIsTrustedOrganizations(candidates, isTrustedOrganizations, candidateMap)
	arrangeValidatorCandidates(candidates, newValidatorCount, isTrustedOrganizations, maxPrioritizedValidatorNumber)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),

		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),
	}

	for i, candidate := range candidates {
		if !bytes.Equal(expectedCandidates[i].Bytes(), candidate.Bytes()) {
			t.Fatal(fmt.Sprintf("mismatched candidate address at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), candidate.Hex()))
		}
	}
}

// TestArrangeValidatorCandidates_Miss5Nodes arranges 16 candidates with 5 trusted nodes (ordering)
func TestArrangeValidatorCandidates_Miss5Nodes(t *testing.T) {
	scenarios := getTestScenarios()
	setIsTrustedAt(scenarios, 11, 12, 13, 14, 15)
	isTrustedOrganizations := getIsTrusted(scenarios)[5:]
	candidates := getAddresses(scenarios)[5:]
	weights := getWeights(scenarios)[5:]
	newValidatorCount := uint64(16)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	candidateMap := createCandidateMap(candidates, isTrustedOrganizations)
	sortValidators(candidates, weights)
	updateIsTrustedOrganizations(candidates, isTrustedOrganizations, candidateMap)
	arrangeValidatorCandidates(candidates, newValidatorCount, isTrustedOrganizations, maxPrioritizedValidatorNumber)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),

		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),

		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
	}
	for i, candidate := range candidates {
		if !bytes.Equal(expectedCandidates[i].Bytes(), candidate.Bytes()) {
			t.Fatal(fmt.Sprintf("mismatched candidate address at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), candidate.Hex()))
		}
	}
}

// TestArrangeValidatorCandidates_Has15TrustedNodes arranges 25 candidates with 15 trusted nodes (ordering)
// while maxPrioritizedValidatorNumber is 11
func TestArrangeValidatorCandidates_Has15TrustedNodes(t *testing.T) {
	scenarios := getTestScenarios()
	scenarios = append(scenarios, []TestScenario{
		{
			Address:   common.BytesToAddress([]byte{121}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{122}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{123}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{124}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
	}...)
	candidates := getAddresses(scenarios)
	weights := getWeights(scenarios)
	setIsTrustedAt(scenarios, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24)
	isTrustedOrganizations := getIsTrusted(scenarios)
	newValidatorCount := uint64(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	candidateMap := createCandidateMap(candidates, isTrustedOrganizations)
	sortValidators(candidates, weights)
	updateIsTrustedOrganizations(candidates, isTrustedOrganizations, candidateMap)
	arrangeValidatorCandidates(candidates, newValidatorCount, isTrustedOrganizations, maxPrioritizedValidatorNumber)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),

		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{124}),
		common.BytesToAddress([]byte{123}),
		common.BytesToAddress([]byte{122}),
		common.BytesToAddress([]byte{121}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
	}

	for i, candidate := range candidates[:newValidatorCount] {
		if !bytes.Equal(expectedCandidates[i].Bytes(), candidate.Bytes()) {
			t.Fatal(fmt.Sprintf("mismatched candidate address at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), candidate.Hex()))
		}
	}
}

// TestArrangeValidatorCandidates_Has15TrustedNodes arranges 25 candidates with 15 trusted nodes (ordering)
// while maxPrioritizedValidatorNumber is 11
func TestArrangeValidatorCandidates_TrustedNodesAtBeginningArray(t *testing.T) {
	scenarios := getTestScenarios()
	scenarios = append(scenarios, []TestScenario{
		{
			Address:   common.BytesToAddress([]byte{121}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{122}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{123}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{124}),
			Weight:    big.NewInt(80_000_000),
			IsTrusted: big0,
		},
	}...)
	candidates := getAddresses(scenarios)
	weights := getWeights(scenarios)
	setIsTrustedAt(scenarios, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	isTrustedOrganizations := getIsTrusted(scenarios)
	newValidatorCount := uint64(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	candidateMap := createCandidateMap(candidates, isTrustedOrganizations)
	sortValidators(candidates, weights)
	updateIsTrustedOrganizations(candidates, isTrustedOrganizations, candidateMap)
	arrangeValidatorCandidates(candidates, newValidatorCount, isTrustedOrganizations, maxPrioritizedValidatorNumber)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),

		common.BytesToAddress([]byte{124}),
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{103}),
	}
	for i, candidate := range candidates[:newValidatorCount] {
		if !bytes.Equal(expectedCandidates[i].Bytes(), candidate.Bytes()) {
			t.Fatal(fmt.Sprintf("mismatched candidate address at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), candidate.Hex()))
		}
	}
}

// TestConsortiumPickValidatorSet_Run init 2 headers, pack them and call `Run` function directly
// Returns 21 candidates if candidates have 21 nodes and 11/21 trusted nodes
func TestConsortiumPickValidatorSet_Run(t *testing.T) {
	statedb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)

	smcAbi := *unmarshalledABIs[PickValidatorSet]
	scenarios := getTestScenarios()
	candidates := getAddresses(scenarios)
	weights := getWeights(scenarios)
	setIsTrustedAt(scenarios, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
	isTrustedOrganizations := getIsTrusted(scenarios)
	maxValidatorNumber := big.NewInt(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),
		common.BytesToAddress([]byte{110}),

		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),
	}

	input, err := smcAbi.Pack(pickValidatorSetMethod, candidates, weights, isTrustedOrganizations, maxValidatorNumber, maxPrioritizedValidatorNumber)

	if err != nil {
		t.Fatal(err)
	}

	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	c := &consortiumPickValidatorSet{caller: AccountRef(caller), evm: evm}
	output, err := c.Run(input)
	if err != nil {
		t.Fatal(err)
	}

	res, err := smcAbi.Methods[pickValidatorSetMethod].Outputs.Unpack(output)
	if err != nil {
		t.Fatal(err)
	}
	validators := *abi.ConvertType(res[0], new([21]common.Address)).(*[21]common.Address)
	if len(expectedCandidates) != len(validators) {
		t.Fatal(fmt.Sprintf("expected len %d, got %v", len(expectedCandidates), len(validators)))
	}

	for i, addr := range validators {
		if expectedCandidates[i].Hex() != addr.Hex() {
			t.Fatal(fmt.Sprintf("mismatched addr at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), addr.Hex()))
		}
	}
}

// TestConsortiumPickValidatorSet_Run2 init 2 headers, pack them and call `Run` function directly
// Returns 15 candidates if candidates have 15 nodes and 5/15 trusted nodes
func TestConsortiumPickValidatorSet_Run2(t *testing.T) {
	statedb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)

	smcAbi := *unmarshalledABIs[PickValidatorSet]
	scenarios := getTestScenarios()
	candidates := getAddresses(scenarios)[:15]
	weights := getWeights(scenarios)[:15]
	setIsTrustedAt(scenarios, 10, 11, 12, 13, 14)
	isTrustedOrganizations := getIsTrusted(scenarios)[:15]
	maxValidatorNumber := big.NewInt(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),
		common.BytesToAddress([]byte{110}),

		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),
	}

	input, err := smcAbi.Pack(pickValidatorSetMethod, candidates, weights, isTrustedOrganizations, maxValidatorNumber, maxPrioritizedValidatorNumber)

	if err != nil {
		t.Fatal(err)
	}

	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	c := &consortiumPickValidatorSet{caller: AccountRef(caller), evm: evm}
	output, err := c.Run(input)
	if err != nil {
		t.Fatal(err)
	}

	res, err := smcAbi.Methods[pickValidatorSetMethod].Outputs.Unpack(output)
	if err != nil {
		t.Fatal(err)
	}
	validators := *abi.ConvertType(res[0], new([15]common.Address)).(*[15]common.Address)
	if len(expectedCandidates) != len(validators) {
		t.Fatal(fmt.Sprintf("expected len %d, got %v", len(expectedCandidates), len(validators)))
	}

	for i, addr := range validators {
		if expectedCandidates[i].Hex() != addr.Hex() {
			t.Fatal(fmt.Sprintf("mismatched addr at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), addr.Hex()))
		}
	}
}

// TestConsortiumPickValidatorSet_Run3 init 2 headers, pack them and call `Run` function directly
// If the length of trusted nodes reach the maxPrioritizedValidatorNumber, then the other trusted nodes
// will be treated as normal nodes
// Returns 21 candidates if candidates have 25 nodes and 15/25 trusted nodes
func TestConsortiumPickValidatorSet_Run3(t *testing.T) {
	statedb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)

	smcAbi := *unmarshalledABIs[PickValidatorSet]
	scenarios := getTestScenarios()
	scenarios = append(scenarios, []TestScenario{
		{
			Address:   common.BytesToAddress([]byte{121}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big1,
		},
		{
			Address:   common.BytesToAddress([]byte{122}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big1,
		},
		{
			Address:   common.BytesToAddress([]byte{123}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big1,
		},
		{
			Address:   common.BytesToAddress([]byte{124}),
			Weight:    big.NewInt(80_000_000), // must be the most priority since the weight is largest
			IsTrusted: big1,
		},
	}...)
	candidates := getAddresses(scenarios)
	weights := getWeights(scenarios)
	setIsTrustedAt(scenarios, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24)
	isTrustedOrganizations := getIsTrusted(scenarios)
	maxValidatorNumber := big.NewInt(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{124}),
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),
		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),

		common.BytesToAddress([]byte{123}),
		common.BytesToAddress([]byte{122}),
		common.BytesToAddress([]byte{121}),

		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
	}

	input, err := smcAbi.Pack(pickValidatorSetMethod, candidates, weights, isTrustedOrganizations, maxValidatorNumber, maxPrioritizedValidatorNumber)

	if err != nil {
		t.Fatal(err)
	}

	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	c := &consortiumPickValidatorSet{caller: AccountRef(caller), evm: evm}
	output, err := c.Run(input)
	if err != nil {
		t.Fatal(err)
	}

	res, err := smcAbi.Methods[pickValidatorSetMethod].Outputs.Unpack(output)
	if err != nil {
		t.Fatal(err)
	}
	validators := *abi.ConvertType(res[0], new([21]common.Address)).(*[21]common.Address)
	fmt.Println(addressesToByte(validators[:]))
	if len(expectedCandidates) != len(validators) {
		t.Fatal(fmt.Sprintf("expected len %d, got %v", len(expectedCandidates), len(validators)))
	}

	for i, addr := range validators {
		if expectedCandidates[i].Hex() != addr.Hex() {
			t.Fatal(fmt.Sprintf("mismatched addr at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), addr.Hex()))
		}
	}
}

// TestConsortiumPickValidatorSet_Run4 init 2 headers, pack them and call `Run` function directly
// Returns 21 candidates if candidates have 25 nodes and 15/25 trusted nodes
// If the length of trusted nodes reach the maxPrioritizedValidatorNumber, then the other trusted nodes
// will be treated as normal nodes
// In case all trusted nodes is at the beginning of the array, the waitingCandidates must not out of bound
func TestConsortiumPickValidatorSet_Run4(t *testing.T) {
	statedb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)

	smcAbi := *unmarshalledABIs[PickValidatorSet]
	scenarios := getTestScenarios()
	scenarios = append(scenarios, []TestScenario{
		{
			Address:   common.BytesToAddress([]byte{121}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{122}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{123}),
			Weight:    big.NewInt(8_000_000),
			IsTrusted: big0,
		},
		{
			Address:   common.BytesToAddress([]byte{124}),
			Weight:    big.NewInt(80_000_000), // must be the most priority since the weight is largest
			IsTrusted: big0,
		},
	}...)
	candidates := getAddresses(scenarios)
	weights := getWeights(scenarios)
	setIsTrustedAt(scenarios, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	isTrustedOrganizations := getIsTrusted(scenarios)
	maxValidatorNumber := big.NewInt(21)
	maxPrioritizedValidatorNumber := big.NewInt(11)

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{110}),
		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),

		common.BytesToAddress([]byte{124}),
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
	}

	input, err := smcAbi.Pack(pickValidatorSetMethod, candidates, weights, isTrustedOrganizations, maxValidatorNumber, maxPrioritizedValidatorNumber)

	if err != nil {
		t.Fatal(err)
	}

	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	c := &consortiumPickValidatorSet{caller: AccountRef(caller), evm: evm}
	output, err := c.Run(input)
	if err != nil {
		t.Fatal(err)
	}

	res, err := smcAbi.Methods[pickValidatorSetMethod].Outputs.Unpack(output)
	if err != nil {
		t.Fatal(err)
	}
	validators := *abi.ConvertType(res[0], new([21]common.Address)).(*[21]common.Address)
	if len(expectedCandidates) != len(validators) {
		t.Fatal(fmt.Sprintf("expected len %d, got %v", len(expectedCandidates), len(validators)))
	}

	for i, addr := range validators {
		if expectedCandidates[i].Hex() != addr.Hex() {
			t.Fatal(fmt.Sprintf("mismatched addr at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), addr.Hex()))
		}
	}
}

// TestConsortiumPickValidatorSet_Run5 simulates a call from a user who trigger system contract
// to call `sort` precompiled contract
func TestConsortiumPickValidatorSet_Run5(t *testing.T) {
	statedb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)
	smcAbi, err := abi.JSON(strings.NewReader(syncNewValidatorSetAbi))
	if err != nil {
		t.Fatal(err)
	}
	input, err := smcAbi.Pack(pickValidatorSetMethod)
	if err != nil {
		t.Fatal(err)
	}

	evm, err := newEVM(caller, statedb)
	if err != nil {
		t.Fatal(err)
	}
	_, contract, _, err := evm.Create(AccountRef(caller), common.FromHex(syncNewValidatorSetCode), math.MaxUint64/2, big0)
	if err != nil {
		t.Fatal(err)
	}

	// set this contract into consortiumV2Contracts to make it become a system contract
	evm.chainConfig.ConsortiumV2Contracts.SlashIndicator = contract

	ret, _, err := evm.StaticCall(AccountRef(caller), contract, input, 1000000)
	if err != nil {
		t.Fatal(err)
	}

	res, err := smcAbi.Methods[pickValidatorSetMethod].Outputs.Unpack(ret)
	if err != nil {
		t.Fatal(err)
	}
	fmt.Println(len(res))
	validators := *abi.ConvertType(res[0], new([21]common.Address)).(*[21]common.Address)
	count := *abi.ConvertType(res[1], new(big.Int)).(*big.Int)
	fmt.Println(validators)
	fmt.Println(count.Uint64())

	expectedCandidates := []common.Address{
		common.BytesToAddress([]byte{120}),
		common.BytesToAddress([]byte{119}),
		common.BytesToAddress([]byte{118}),
		common.BytesToAddress([]byte{117}),
		common.BytesToAddress([]byte{116}),
		common.BytesToAddress([]byte{115}),
		common.BytesToAddress([]byte{114}),
		common.BytesToAddress([]byte{113}),
		common.BytesToAddress([]byte{112}),
		common.BytesToAddress([]byte{111}),
		common.BytesToAddress([]byte{110}),

		common.BytesToAddress([]byte{109}),
		common.BytesToAddress([]byte{108}),
		common.BytesToAddress([]byte{107}),
		common.BytesToAddress([]byte{106}),
		common.BytesToAddress([]byte{105}),
		common.BytesToAddress([]byte{104}),
		common.BytesToAddress([]byte{103}),
		common.BytesToAddress([]byte{102}),
		common.BytesToAddress([]byte{101}),
		common.BytesToAddress([]byte{100}),
	}

	if len(expectedCandidates) != len(validators) {
		t.Fatal(fmt.Sprintf("expected len 21, got %v", len(validators)))
	}

	for i, addr := range validators {
		if expectedCandidates[i].Hex() != addr.Hex() {
			t.Fatal(fmt.Sprintf("mismatched addr at %d, expected:%s got:%s", i, expectedCandidates[i].Hex(), addr.Hex()))
		}
	}
}

func BenchmarkConsortiumPickValidatorSet(b *testing.B) {
	smcAbi, err := abi.JSON(strings.NewReader(rawConsortiumPickValidatorSetAbi))
	if err != nil {
		b.Fatal(err)
	}

	var (
		addresses      []common.Address
		weights        []*big.Int
		trustedWeights []*big.Int
	)
	for i := 0; i < 22; i++ {
		addresses = append(addresses, common.BytesToAddress([]byte{uint8(i)}))
		weights = append(weights, big.NewInt(rand.Int63()))
		trustedWeights = append(trustedWeights, big0)
	}

	input, err := smcAbi.Pack(pickValidatorSetMethod, addresses, weights, trustedWeights, big.NewInt(22), big0)
	if err != nil {
		b.Fatal(err)
	}

	c := &consortiumPickValidatorSet{}
	output, err := c.Run(input)
	if err != nil {
		b.Fatal(err)
	}

	test := precompiledTest{
		Input:    common.Bytes2Hex(input),
		Expected: common.Bytes2Hex(output),
		Name:     "pick-validator-set",
	}

	benchmarkPrecompiled("68", test, b)

	addresses = nil
	weights = nil
	trustedWeights = nil
	for i := 0; i < 100; i++ {
		addresses = append(addresses, common.BytesToAddress([]byte{uint8(i)}))
		weights = append(weights, big.NewInt(rand.Int63()))
		trustedWeights = append(trustedWeights, big0)
	}

	input, err = smcAbi.Pack(pickValidatorSetMethod, addresses, weights, trustedWeights, big.NewInt(100), big0)
	if err != nil {
		b.Fatal(err)
	}

	output, err = c.Run(input)
	if err != nil {
		b.Fatal(err)
	}

	test = precompiledTest{
		Input:    common.Bytes2Hex(input),
		Expected: common.Bytes2Hex(output),
		Name:     "pick-validator-set",
	}

	benchmarkPrecompiled("68", test, b)
}

func prepareHeader(chainId *big.Int) (*types.Header, *types.Header, error) {
	privateKey, err := crypto.GenerateKey()
	if err != nil {
		return nil, nil, err
	}
	// init extraData with extraVanity
	extraData := bytes.Repeat([]byte{0x00}, extraVanity)

	// append to extraData with validators set
	extraData = append(extraData, common.BytesToAddress([]byte("validator1")).Bytes()...)
	extraData = append(extraData, common.BytesToAddress([]byte("validator2")).Bytes()...)

	// add extra seal space
	extraData = append(extraData, make([]byte, crypto.SignatureLength)...)

	// create header1
	header1 := &types.Header{
		ParentHash:  common.BytesToHash([]byte("11")),
		UncleHash:   common.Hash{},
		Coinbase:    crypto.PubkeyToAddress(privateKey.PublicKey),
		Root:        common.BytesToHash([]byte("123")),
		TxHash:      common.BytesToHash([]byte("abc")),
		ReceiptHash: common.BytesToHash([]byte("def")),
		Bloom:       types.Bloom{},
		Difficulty:  big.NewInt(1000),
		Number:      big.NewInt(1000),
		GasLimit:    100000000,
		GasUsed:     0,
		Time:        1000,
		Extra:       make([]byte, len(extraData)),
		MixDigest:   common.Hash{},
		Nonce:       types.EncodeNonce(1000),
	}

	// create header2
	header2 := &types.Header{
		ParentHash:  common.BytesToHash([]byte("11")),
		UncleHash:   common.Hash{},
		Coinbase:    crypto.PubkeyToAddress(privateKey.PublicKey),
		Root:        common.BytesToHash([]byte("1232")),
		TxHash:      common.BytesToHash([]byte("abcd")),
		ReceiptHash: common.BytesToHash([]byte("defd")),
		Bloom:       types.Bloom{},
		Difficulty:  big.NewInt(1000),
		Number:      big.NewInt(1000),
		GasLimit:    100000000,
		GasUsed:     0,
		Time:        1000,
		Extra:       make([]byte, len(extraData)),
		MixDigest:   common.Hash{},
		Nonce:       types.EncodeNonce(1000),
	}

	// copy extraData
	copy(header1.Extra[:], extraData)
	copy(header2.Extra[:], extraData)

	// signing and add to extraData
	blockHeader1 := types.FromHeader(header1, chainId, false)
	sig1, err := crypto.Sign(SealHash(blockHeader1).Bytes(), privateKey)
	if err != nil {
		return nil, nil, err
	}
	blockHeader2 := types.FromHeader(header2, chainId, false)
	sig2, err := crypto.Sign(SealHash(blockHeader2).Bytes(), privateKey)
	if err != nil {
		return nil, nil, err
	}

	copy(header1.Extra[len(header1.Extra)-crypto.SignatureLength:], sig1)
	copy(header2.Extra[len(header2.Extra)-crypto.SignatureLength:], sig2)

	return header1, header2, nil
}

func newEVM(caller common.Address, statedb StateDB) (*EVM, error) {
	evm := &EVM{
		Context: BlockContext{
			CanTransfer: func(state StateDB, addr common.Address, value *big.Int) bool { return true },
			Transfer:    func(StateDB, common.Address, common.Address, *big.Int) {},
			BlockNumber: common.Big1,
		},
		chainConfig: params.TestChainConfig,
		StateDB:     statedb,
		chainRules:  params.Rules{IsIstanbul: true, IsEIP150: true, IsConsortiumV2: true},
	}
	evm.chainConfig.ConsortiumV2Block = common.Big1
	evm.interpreter = NewEVMInterpreter(evm, Config{NoBaseFee: true})
	_, contract, _, err := evm.Create(AccountRef(caller), common.FromHex(testSortCode), math.MaxUint64/2, big0)
	if err != nil {
		return nil, err
	}
	evm.chainConfig.ConsortiumV2Contracts = &params.ConsortiumV2Contracts{
		StakingContract:   contract,
		RoninValidatorSet: contract,
		SlashIndicator:    caller,
	}
	return evm, nil
}

func addressesToByte(addresses []common.Address) [][]byte {
	var result [][]byte
	for _, addr := range addresses {
		var value []byte
		for _, b := range addr.Bytes() {
			if b != 0 {
				value = append(value, b)
			}
		}
		result = append(result, value)
	}

	return result
}

func TestValidateFinalityVoteProof(t *testing.T) {
	contract := consortiumValidateFinalityProof{}

	contractAbi := *unmarshalledABIs[ValidateFinalityVoteProof]

	var (
		secretKey [3]blsCommon.SecretKey
		err       error
	)
	for i := 0; i < 3; i++ {
		secretKey[i], err = blst.RandKey()
		if err != nil {
			t.Fatalf("Failed to generate key, err %s", err)
		}
	}
	var blockNumber uint64 = 1
	blockHash1 := common.Hash{0x1}
	voteData1 := types.VoteData{
		TargetNumber: blockNumber,
		TargetHash:   blockHash1,
	}
	digest1 := voteData1.Hash()
	blockHash2 := common.Hash{0x2}
	voteData2 := types.VoteData{
		TargetNumber: blockNumber,
		TargetHash:   blockHash2,
	}
	digest2 := voteData2.Hash()

	targetBlockHashes := [2]common.Hash{blockHash1, blockHash1}
	listOfPublicKeys := [2][][]byte{
		{
			secretKey[0].PublicKey().Marshal(),
		},
		{
			secretKey[0].PublicKey().Marshal(),
		},
	}
	voterPublicKey := secretKey[0].PublicKey().Marshal()
	aggregatedSignature := [2][]byte{
		secretKey[0].Sign(digest1[:]).Marshal(),
		secretKey[0].Sign(digest1[:]).Marshal(),
	}

	input, err := contractAbi.Pack(
		validateFinalityVoteProof,
		voterPublicKey,
		new(big.Int).Add(new(big.Int).SetUint64(1<<64-1), common.Big1),
		targetBlockHashes,
		listOfPublicKeys,
		aggregatedSignature,
	)
	if err != nil {
		t.Fatalf("Failed to pack contract input, err: %s", err)
	}

	_, err = contract.Run(input)
	if err == nil || err.Error() != "malformed target block number" {
		t.Fatalf("Expect to get error %s have %s", "malformed target block number", err)
	}

	input, err = contractAbi.Pack(
		validateFinalityVoteProof,
		voterPublicKey,
		big.NewInt(int64(blockNumber)),
		targetBlockHashes,
		listOfPublicKeys,
		aggregatedSignature,
	)
	if err != nil {
		t.Fatalf("Failed to pack contract input, err: %s", err)
	}

	_, err = contract.Run(input)
	if err == nil || err.Error() != "block hash is the same" {
		t.Fatalf("Expect to get error %s have %s", "block hash is the same", err)
	}

	targetBlockHashes = [2]common.Hash{
		blockHash1,
		blockHash2,
	}
	aggregatedSignature = [2][]byte{
		secretKey[0].Sign(digest1[:]).Marshal(),
		secretKey[1].Sign(digest2[:]).Marshal(),
	}
	listOfPublicKeys = [2][][]byte{
		{
			secretKey[0].PublicKey().Marshal(),
		},
		{
			secretKey[1].PublicKey().Marshal(),
		},
	}

	input, err = contractAbi.Pack(
		validateFinalityVoteProof,
		voterPublicKey,
		big.NewInt(int64(blockNumber)),
		targetBlockHashes,
		listOfPublicKeys,
		aggregatedSignature,
	)
	if err != nil {
		t.Fatalf("Failed to pack contract input, err: %s", err)
	}

	_, err = contract.Run(input)
	if err == nil || err.Error() != "reported voter does not in public key list" {
		t.Fatalf("Expect to get error %s have %s", "reported voter does not in public key list", err)
	}

	aggregatedSignature = [2][]byte{
		blst.AggregateSignatures([]blsCommon.Signature{
			secretKey[0].Sign(digest1[:]),
			secretKey[1].Sign(digest1[:]),
		}).Marshal(),
		blst.AggregateSignatures([]blsCommon.Signature{
			secretKey[0].Sign(digest2[:]),
			secretKey[2].Sign(digest2[:]),
		}).Marshal(),
	}

	listOfPublicKeys = [2][][]byte{
		{
			secretKey[0].PublicKey().Marshal(),
			secretKey[1].PublicKey().Marshal(),
		},
		{
			secretKey[0].PublicKey().Marshal(),
			secretKey[2].PublicKey().Marshal(),
		},
	}

	input, err = contractAbi.Pack(
		validateFinalityVoteProof,
		voterPublicKey,
		big.NewInt(int64(blockNumber)),
		targetBlockHashes,
		listOfPublicKeys,
		aggregatedSignature,
	)
	if err != nil {
		t.Fatalf("Failed to pack contract input, err: %s", err)
	}

	rawReturn, err := contract.Run(input)
	if err != nil {
		t.Fatalf("Expect to successfully verify proof, get %s", err)
	}

	ret, err := contractAbi.Unpack(validateFinalityVoteProof, rawReturn)
	if err != nil {
		t.Fatalf("Failed to unpack output, err: %s", err)
	}

	returnedBool := (ret[0]).(bool)
	if returnedBool != true {
		t.Fatalf("Expect the returned value to be true, get %v", returnedBool)
	}
}

func BenchmarkPrecompiledValidateFinalityVoteProof(b *testing.B) {
	contractAbi := *unmarshalledABIs[ValidateFinalityVoteProof]

	var secretKeys []blsCommon.SecretKey
	for i := 0; i < 200; i++ {
		key, err := blst.RandKey()
		if err != nil {
			b.Fatalf("Failed to generate secret key")
		}

		secretKeys = append(secretKeys, key)
	}
	blockNumber := 10000
	blockHash1 := crypto.Keccak256Hash([]byte{'t', 'e', 's', 't'})
	vote := types.VoteData{
		TargetNumber: uint64(blockNumber),
		TargetHash:   blockHash1,
	}
	digest1 := vote.Hash()

	blockHash2 := crypto.Keccak256Hash([]byte{'t', 'e', 's', 't', '2'})
	vote = types.VoteData{
		TargetNumber: uint64(blockNumber),
		TargetHash:   blockHash2,
	}
	digest2 := vote.Hash()

	var signature [100]blsCommon.Signature
	var listOfPublicKey [2][][]byte
	for i := 0; i < 100; i++ {
		signature[i] = secretKeys[i].Sign(digest1[:])
		listOfPublicKey[0] = append(listOfPublicKey[0], secretKeys[i].PublicKey().Marshal())
	}
	aggregatedSignature1 := blst.AggregateSignatures(signature[:])

	signature[0] = secretKeys[0].Sign(digest2[:])
	listOfPublicKey[1] = append(listOfPublicKey[1], secretKeys[0].PublicKey().Marshal())
	for i := 101; i < 200; i++ {
		signature[i-100] = secretKeys[i].Sign(digest2[:])
		listOfPublicKey[1] = append(listOfPublicKey[1], secretKeys[i].PublicKey().Marshal())
	}
	aggregatedSignature2 := blst.AggregateSignatures(signature[:])

	input, err := contractAbi.Pack(
		validateFinalityVoteProof,
		secretKeys[0].PublicKey().Marshal(),
		big.NewInt(int64(blockNumber)),
		[2]common.Hash{
			blockHash1,
			blockHash2,
		},
		listOfPublicKey,
		[2][]byte{
			aggregatedSignature1.Marshal(),
			aggregatedSignature2.Marshal(),
		},
	)
	if err != nil {
		b.Fatalf("Failed to pack contract input, err: %s", err)
	}

	output, err := contractAbi.Methods[validateFinalityVoteProof].Outputs.Pack(true)
	if err != nil {
		b.Fatalf("Failed to pack contract output, err: %s", err)
	}

	test := precompiledTest{
		Input:    common.Bytes2Hex(input),
		Expected: common.Bytes2Hex(output),
		Name:     "200-public-keys",
	}

	benchmarkPrecompiled("69", test, b)
}

func TestValidateProofOfPossession(t *testing.T) {
	contract := consortiumValidateProofOfPossession{}
	contractAbi := *unmarshalledABIs[ValidateProofOfPossession]

	// Generated by `ronin account generate-bls-proof`
	publicKey := common.Hex2Bytes("a9efd6ee7841b5703c70be3348fd546710069ec6912f123b6bb414aaf4815c68f3daa0ab9fb3c18f8cd3af88352ba72b")
	proof := common.Hex2Bytes("a93f4ec59b89a3fcab0e71fd0e94990a7ecb28b65bbafd2a03b8ed7bfd480ebbf98c49cacb01fd98f4b24d126a46e3740cfc590f3ae3dd10b9c18f04de158b909f2886ef6dde4c9e01f83d92f33aa2027f825b718e2fe184ea2c952aeca33713")

	input, err := contractAbi.Pack(validateProofOfPossession, publicKey, proof)
	if err != nil {
		t.Fatalf("Failed to pack contract input, err %s", err)
	}

	rawReturn, err := contract.Run(input)
	if err != nil {
		t.Fatalf("Precompiled contract returns error, err %s", err)
	}

	ret, err := contractAbi.Unpack(validateProofOfPossession, rawReturn)
	if err != nil {
		t.Fatalf("Failed to unpack output, err: %s", err)
	}

	returnedBool := (ret[0]).(bool)
	if returnedBool != true {
		t.Fatalf("Expect the returned value to be true, get %v", returnedBool)
	}
}

func BenchmarkPrecompiledValidateProofOfPossession(b *testing.B) {
	contractAbi := *unmarshalledABIs[ValidateProofOfPossession]

	// Generated by `ronin account generate-bls-proof`
	publicKey := common.Hex2Bytes("a9efd6ee7841b5703c70be3348fd546710069ec6912f123b6bb414aaf4815c68f3daa0ab9fb3c18f8cd3af88352ba72b")
	proof := common.Hex2Bytes("a93f4ec59b89a3fcab0e71fd0e94990a7ecb28b65bbafd2a03b8ed7bfd480ebbf98c49cacb01fd98f4b24d126a46e3740cfc590f3ae3dd10b9c18f04de158b909f2886ef6dde4c9e01f83d92f33aa2027f825b718e2fe184ea2c952aeca33713")

	input, err := contractAbi.Pack(validateProofOfPossession, publicKey, proof)
	if err != nil {
		b.Fatalf("Failed to pack contract input, err %s", err)
	}

	output, err := contractAbi.Methods[validateProofOfPossession].Outputs.Pack(true)
	if err != nil {
		b.Fatalf("Failed to pack contract output, err: %s", err)
	}

	test := precompiledTest{
		Input:    common.Bytes2Hex(input),
		Expected: common.Bytes2Hex(output),
		Name:     "proof-of-possession",
	}

	benchmarkPrecompiled("6a", test, b)
}

func Test_consortiumVerifyHeaders_getSigner(t *testing.T) {
	privateKey, err := crypto.GenerateKey()
	if err != nil {
		t.Fatal(err)
	}

	extraData := bytes.Repeat([]byte{0x00}, extraVanity)
	// append to extraData with validators set
	extraData = append(extraData, common.BytesToAddress([]byte("validator1")).Bytes()...)
	extraData = append(extraData, common.BytesToAddress([]byte("validator2")).Bytes()...)
	// add extra seal space
	extraData = append(extraData, make([]byte, crypto.SignatureLength)...)

	type args struct {
		blockHeader *types.Header
		chainId     *big.Int
		isVenoki    bool
	}
	tests := []struct {
		name    string
		args    args
		want    common.Address
		wantErr bool
	}{
		{
			name: "Get signer from header before Venoki",
			args: args{
				blockHeader: &types.Header{
					ParentHash:  common.BytesToHash([]byte("11")),
					UncleHash:   common.Hash{},
					Coinbase:    crypto.PubkeyToAddress(privateKey.PublicKey),
					Root:        common.BytesToHash([]byte("123")),
					TxHash:      common.BytesToHash([]byte("abc")),
					ReceiptHash: common.BytesToHash([]byte("def")),
					Bloom:       types.Bloom{},
					Difficulty:  big.NewInt(1000),
					Number:      big.NewInt(1000),
					GasLimit:    100000000,
					GasUsed:     0,
					Time:        1000,
					Extra:       make([]byte, len(extraData)),
					MixDigest:   common.Hash{},
					Nonce:       types.EncodeNonce(1000),
				},
				chainId:  big1,
				isVenoki: false,
			},
			want:    crypto.PubkeyToAddress(privateKey.PublicKey),
			wantErr: false,
		},
		{
			name: "Get signer from header after Venoki",
			args: args{
				blockHeader: &types.Header{
					ParentHash:  common.BytesToHash([]byte("11")),
					UncleHash:   common.Hash{},
					Coinbase:    crypto.PubkeyToAddress(privateKey.PublicKey),
					Root:        common.BytesToHash([]byte("123")),
					TxHash:      common.BytesToHash([]byte("abc")),
					ReceiptHash: common.BytesToHash([]byte("def")),
					Bloom:       types.Bloom{},
					Difficulty:  big.NewInt(1000),
					Number:      big.NewInt(1000),
					GasLimit:    100000000,
					GasUsed:     0,
					Time:        1000,
					Extra:       make([]byte, len(extraData)),
					MixDigest:   common.Hash{},
					Nonce:       types.EncodeNonce(1000),
					BaseFee:     big.NewInt(20_000),
				},
				chainId:  big1,
				isVenoki: true,
			},
			want:    crypto.PubkeyToAddress(privateKey.PublicKey),
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &consortiumVerifyHeaders{
				evm: &EVM{
					chainConfig: &params.ChainConfig{
						ChainID:           tt.args.chainId,
						ConsortiumV2Block: big.NewInt(500),
					},
					Context: BlockContext{BlockNumber: big.NewInt(1000)},
				},
				test: true,
			}
			copy(tt.args.blockHeader.Extra[:], extraData)
			blockHeader := types.FromHeader(tt.args.blockHeader, tt.args.chainId, tt.args.isVenoki)
			header := blockHeader.ToHeader()
			sealHash := SealHash(blockHeader).Bytes()
			sig, err := crypto.Sign(sealHash, privateKey)
			if err != nil {
				t.Fatal(err)
			}

			// copy signature to extraData
			copy(header.Extra[len(tt.args.blockHeader.Extra)-crypto.SignatureLength:], sig)
			got, err := c.getSigner(blockHeader)
			if (err != nil) != tt.wantErr {
				t.Errorf("getSigner() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got.Cmp(tt.want) != 0 {
				t.Errorf("getSigner() got = %v, want %v", got.Hex(), tt.want.Hex())
			}
		})
	}
}

func signHeader(privateKey *ecdsa.PrivateKey, header *types.Header, chainId *big.Int, isVenoki bool) {
	blockHeader := types.FromHeader(header, chainId, isVenoki)
	sealHash := SealHash(blockHeader).Bytes()
	sig, err := crypto.Sign(sealHash, privateKey)
	if err != nil {
		panic(err)
	}
	copy(header.Extra[len(header.Extra)-crypto.SignatureLength:], sig)
}

func mockVenokiHeader(privateKey *ecdsa.PrivateKey) *types.Header {
	gas := uint64(2000)
	return &types.Header{
		ParentHash:    common.BytesToHash([]byte("11")),
		UncleHash:     common.Hash{},
		Coinbase:      crypto.PubkeyToAddress(privateKey.PublicKey),
		Root:          common.BytesToHash([]byte("123")),
		TxHash:        common.BytesToHash([]byte("abc")),
		ReceiptHash:   common.BytesToHash([]byte("def")),
		Bloom:         types.Bloom{},
		Difficulty:    big.NewInt(1000),
		Number:        big.NewInt(1000),
		GasLimit:      100000000,
		GasUsed:       0,
		Time:          1000,
		MixDigest:     common.Hash{},
		Extra:         make([]byte, 0),
		Nonce:         types.EncodeNonce(1000),
		BaseFee:       big.NewInt(20_000),
		BlobGasUsed:   &gas,
		ExcessBlobGas: &gas,
	}
}

func Test_consortiumVerifyHeaders_unpackHeader(t *testing.T) {
	smcAbi := *unmarshalledABIs[VerifyHeaders]
	key, _ := crypto.GenerateKey()
	header := mockVenokiHeader(key)
	abi := rawConsortiumVerifyHeadersV2Abi
	blockHeader1 := types.FromHeader(header, big1, true)

	encodedHeader, err := blockHeader1.Bytes(abi, getHeader)
	if err != nil {
		t.Fatal(err)
	}
	input, err := smcAbi.Pack(verifyHeaders, header.Coinbase, encodedHeader, encodedHeader)
	if err != nil {
		t.Fatal(err)
	}

	// get method, args from abi and check if method is valid
	smcAbi, _, args, err := loadMethodAndArgs(VerifyHeadersVenoki, input)
	if err != nil {
		t.Fatal(err)
	}
	statedb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)
	evm, err := newEVM(caller, statedb)
	c := &consortiumVerifyHeaders{evm: evm, caller: AccountRef(caller), test: true}
	recoveredHeader, err := c.unpackHeader(smcAbi, args[1].([]byte), true)
	if err != nil {
		t.Fatal(err)
	}

	rec := recoveredHeader.ToHeader()
	assert.EqualValues(t, header, rec)
}
